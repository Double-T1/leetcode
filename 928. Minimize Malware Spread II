//the question is a variant on components
//hence can be dealt with either union find or DFS

//brute force
//time: O(v**3)
var minMalwareSpread = function(graph, initial) {
    let infectedNum = graph.length
    let candidate = null
    //O(v)
    for (let i=initial.length-1; i>=0; i--) {
        let num = infectNum(initial[i],initial,graph)
        if (num <= infectedNum) {
            infectedNum = num
            candidate = initial[i]
        }
    }
    return candidate
};

let infectNum = (i,initial,graph) => {
    let visited = {}
    visited[i] = true
    let infected = 0
    //O(v**2)
    for (let start of initial) {
        if (visited[start]) continue
        let queue = [start]
        visited[start] = true
        while (queue.length) {
            infected++
            let i = queue.pop()
            //O(v)
            for (let j=0; j<graph[i].length; j++) {
                if (graph[i][j] === 0 || visited[j]) continue 
                visited[j] = true
                queue.unshift(j)
            }
        } 
    }
    return infected
}

//worst case is when the whole graph is connected, 
//hence we have to traverse all edges and vertices for all the initials vertices
//time: O(k*(V**2)) 
//k is the amount of initial nodes
var minMalwareSpread2 = function(graph, initial) {
    let mal = new Set()
    //O(V)
    for (let i of initial) {
        mal.add(i)
    }

    let affectRange = 0 
    let candidate = graph.length
    //O(V+E)
    for (let i of initial) {
        let num = range(mal,graph,i)
        if (num > affectRange) {
            candidate = i
            affectRange = num
        } else if (num === affectRange) {
            candidate = Math.min(i,candidate)
        }
    }
    return candidate
};

let range = (mal,graph,source,visited={}) => {
    visited[source] = true
    let count = 0
    for (let j=0; j<graph[source].length; j++) {
        if (graph[source][j] === 0 || source === j) continue
        let num = dfs(mal,graph,j,source,visited)
        if (num>0) count+= num
    }
    return count
}

//O(V**2)
let dfs = (mal,graph,current,source,visited) => {
    if (visited[current]) return 0
    if (mal.has(current)) return -1
    
    visited[current] = true
    let nodes = 1
    for (let j=0; j<graph[current].length; j++) {
        if (graph[current][j] === 0) continue
        let num = dfs(mal,graph,j,source,visited)
        if (num === -1 || nodes === -1) {
            nodes = -1
        } else {
            nodes += num
        }
    }
    return nodes
}




let graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
console.log(minMalwareSpread2(graph,initial))
